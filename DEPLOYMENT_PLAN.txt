# APEX ENGINE: ENTERPRISE DEPLOYMENT & ARCHITECTURE PLAN
# =========================================================
# Location: d:\code\AntiGravity\pdftoolskit-main\DEPLOYMENT_PLAN.txt
# Version: 1.0.0 (True Apex Engine Release)

1. THE CORE CHALLENGE: THE BINARY GAP
------------------------------------
The "True Apex Engine" is not a typical JavaScript library. It relies on a 
compiled C++ core (LibreOffice LOKit) translated into WebAssembly (WASM).

*   SOURCE SIZE: ~200MB of C++ source code.
*   COMPILATION TIME: ~4 hours (Local Hardware).
*   VERCEL BUILD LIMIT: 45 Minutes (Hard Timeout).

STRATEGY: Because Vercel will time out during C++ compilation, we use the 
"COMPILED ASSET" strategy. We compile the "Muscle" (WASM binary) locally and 
commit the artifact to Git, treating it as a static deployment asset.

2. LOCAL BUILD PIPELINE (NO SHORTCUTS)
--------------------------------------
Developers must generate the Apex binary once or whenever the core logic changes.

A. Prerequisites:
   - Docker Desktop (Running with Linux Containers).
   - PowerShell (on Windows) or Bash (on Linux/Mac).

B. Build Command:
   PS> .\scripts\build-apex-wasm.ps1
   (or) 
   $ sh scripts/build-apex-wasm.sh

C. Output:
   The script generates `public/wasm/apex-doc.wasm`. This file MUST be committed
   to the repository to allow Vercel to serve it.

3. VERCEL DEPLOYMENT CONFIGURATION
----------------------------------
High-performance document processing requires multi-threading and zero-copy 
memory. This is achieved via `SharedArrayBuffer`, which modern browsers block 
unless specific security headers are present.

REQUIRED vercel.json HEADERS:
----------------------------
{
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        { "key": "Cross-Origin-Opener-Policy", "value": "same-origin" },
        { "key": "Cross-Origin-Embedder-Policy", "value": "require-corp" }
      ]
    }
  ]
}

Without these headers, the `worker-pool.ts` will gracefully degrade to 
Single-Threaded mode, losing 70% of its performance.

4. ARCHITECTURAL HIERARCHY
--------------------------
1. APEX CORE WORKER (lib/engines/apex-core.worker.ts)
   - Manages the Virtual File System (VFS).
   - Bridges JS memory to WASM sandboxes.
2. UNIVERSAL TYPOGRAPHY REGISTRY (lib/engines/typography-registry.ts)
   - Performs font-matching for proprietary Windows/Mac fonts.
   - Dynamically fetches .woff2 clones from Edge CDNs.
3. WEBGPU VISION ENGINE (lib/engines/webgpu-vision.ts)
   - Offloads mathematical morphology to the GPU.
   - Performs 60FPS quad-detection and Forensic Deep-Cleaning.

5. SUMMARY FOR FUTURE DEVELOPERS
--------------------------------
Do NOT attempt to refactor the conversion logic into pure JavaScript. 
The fidelity of this engine depends on the mathematical determinism of the 
WASM-compiled C++ binaries. If you touch the layout engine, you MUST re-run 
the build scripts in /scripts and extract the new .wasm binary.

"Architecture is the art of making the impossible inevitable."
- Apex Engine Lead Architect
