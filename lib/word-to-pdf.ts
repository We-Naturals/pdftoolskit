import jsPDF from 'jspdf';
import JSZip from 'jszip';

/**
 * Convert Word (DOCX) to PDF
 * Extracts text from word/document.xml (Best Effort)
 * Note: Client-side only. Cannot render complex layouts perfectly.
 */
export async function wordToPdf(file: File): Promise<Uint8Array> {
    const arrayBuffer = await file.arrayBuffer();
    const zip = await JSZip.loadAsync(arrayBuffer);

    const doc = new jsPDF();
    const margin = 20;
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const maxWidth = pageWidth - (margin * 2);

    let yPos = 30;

    // Header / Title
    doc.setFontSize(18);
    doc.setTextColor(40, 40, 40);
    doc.text(file.name.replace(/\.[^/.]+$/, ""), margin, yPos);
    yPos += 15;

    // Load document.xml
    const documentXmlFile = zip.file('word/document.xml');
    if (!documentXmlFile) {
        doc.setFontSize(12);
        doc.text("Could not find document content. This might be a legacy or corrupted docx.", margin, yPos);
        return new Uint8Array(doc.output('arraybuffer'));
    }

    const docXml = await documentXmlFile.async('string');
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(docXml, 'text/xml');

    // Extract text paragraphs (w:p)
    const paragraphs = xmlDoc.getElementsByTagName('w:p');

    doc.setFontSize(11);
    doc.setTextColor(60, 60, 60);

    for (let i = 0; i < paragraphs.length; i++) {
        // eslint-disable-next-line security/detect-object-injection
        const p = paragraphs[i];
        // Extract all text nodes (w:t) within this paragraph
        const textNodes = p.getElementsByTagName('w:t');
        let pText = '';
        for (let j = 0; j < textNodes.length; j++) {
            // eslint-disable-next-line security/detect-object-injection
            pText += textNodes[j].textContent || '';
        }

        if (pText.trim()) {
            const lines = doc.splitTextToSize(pText, maxWidth);

            // Handle page breaks
            if (yPos + (lines.length * 6) > pageHeight - margin) {
                doc.addPage();
                yPos = margin;
            }

            doc.text(lines, margin, yPos);
            yPos += (lines.length * 6) + 4;
        } else {
            // Empty paragraph (spacer)
            yPos += 4;
        }

        // Safety check for extreme lengths
        if (yPos > pageHeight - margin) {
            doc.addPage();
            yPos = margin;
        }
    }

    // Add Branding / Footer
    const internalDoc = doc as any;
    const totalPages = internalDoc.internal.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.setTextColor(150);
        doc.text(`Page ${i} of ${totalPages} | Generated by PDFToolskit`, pageWidth / 2, pageHeight - 10, { align: 'center' });
    }

    return new Uint8Array(doc.output('arraybuffer'));
}
